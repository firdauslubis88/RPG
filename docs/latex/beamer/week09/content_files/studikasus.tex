% ===================================================
% STUDI KASUS 2 (SK 2) - KONTEKS REVISI
% ===================================================

% ===================================================
% STUDI KASUS 2 (REVISI)
% ===================================================
\section{Studi Kasus A.1}
\begin{frame}[t,fragile]
    \frametitle{Analisis Desain ``\textit{Object Drilling}'' (1/3)}
    \footnotesize
    \begin{spacing}{0.85}
    
    Studi kasus ini menantang kita untuk menganalisis \textbf{manajemen dependensi} dalam sebuah arsitektur yang \textit{tightly coupled} (terikat erat).
    
    \medskip
    Akar masalah ini terletak pada \textbf{Siklus Hidup (Lifecycle)} LibGDX. \textit{Lifecycle} ini membagi tugas secara ketat:
    \begin{itemize}
        \item \texttt{create()}: Sebagai \textbf{Fase Perakitan} (Assembly Phase). Berjalan satu kali untuk inisialisasi dan konstruksi \textit{object graph}.
        \item \texttt{render()}: Sebagai \textbf{Fase Operasi} (Operational Phase). Berjalan berulang kali (loop) untuk mengeksekusi logika dan rendering.
    \end{itemize}
    
    \medskip
    Karena \texttt{create()} adalah satu-satunya fase perakitan, \texttt{MyGame} (sebagai \textit{root object}) dipaksa untuk bertindak sebagai \textbf{"Mandor Perakitan"}. Secara formal, ini berarti \texttt{MyGame} bertanggung jawab untuk melakukan \textit{manual dependency injection} untuk \textbf{seluruh} rantai objek yang dibuatnya. Perhatikan contoh implementasi arsitektur ini yang awalnya adalah:
    
    \end{spacing}    
\end{frame}

\begin{frame}[t,fragile]
    \frametitle{Analisis Desain ``\textit{Object Drilling}'' (2/3)}
    \footnotesize
    \begin{spacing}{0.85}
    Awalnya, program menerapkan arsitektur "inisialisasi terpusat" seperti ini:

    \begin{minted}[fontsize=\tiny, bgcolor=gray!10]{java}
    // KODE AWAL:
    public class Player {
        private GameManager manager;
        public Player(GameManager manager) { this.manager = manager; }
        public void collectCoin() { manager.addScore(10); }
    }
    public class GameScreen {
        private Player player;
        // GameScreen tidak butuh manager, tapi Player butuh
        public GameScreen(GameManager manager) {
            this.player = new Player(manager);
        }
    }
    public class MyGame implements ApplicationListener {
        private GameManager manager;
        private GameScreen screen;
        public void create() {
            this.manager = new GameManager();
            this.screen = new GameScreen(this.manager); 
        }
    }
    \end{minted}
    \end{spacing}    
\end{frame}

\begin{frame}[fragile]
    \frametitle{Analisis Desain ``\textit{Object Drilling}'' (3/3)}
    \footnotesize
    \begin{spacing}{0.8}
    Lalu, muncul kebutuhan baru: \texttt{Player} sekarang juga harus memutar suara via \texttt{AudioManager}. Mengikuti pola sebelumnya, "Mandor" (\texttt{MyGame}) dan "Perantara" (\texttt{GameScreen}) dipaksa untuk "meng-bor" (drill) dependensi baru ini.
    \vspace{-2mm}
    \begin{columns}[T]
    \begin{column}{0.7\textwidth}
    \begin{minted}[fontsize=\tiny, bgcolor=gray!10, escapeinside=||]{java}
    // KODE SETELAH PERUBAHAN:
    public class Player {
        private GameManager manager;
        private AudioManager audio; // <--- BARIS BARU 1
        
        public Player(GameManager manager, AudioManager audio) { // <--- BARIS BARU 2
            this.manager = manager;
            this.audio = audio; // <--- BARIS BARU 3
        }
        public void collectCoin() {
            manager.addScore(10);
            audio.playSound("coin"); // <--- BARIS BARU 4
        }
    }
    public class GameScreen {
        private Player player;
        // GameScreen TIDAK BUTUH dependensi ini, tapi dipaksa tahu
        private AudioManager audio; // <--- BARIS BARU 5
        private GameManager manager; // <--- BARIS LAMA

        public GameScreen(GameManager manager, AudioManager audio) { // <--- BARIS BARU 6
            this.manager = manager;
            this.audio = audio;
            // Mengoper kedua dependensi ke Player
            this.player = new Player(this.manager, this.audio); // <--- BARIS BARU 7
        }
    }
    \end{minted}
    \end{column}
    \begin{column}{0.3\textwidth}
    \begin{minted}[fontsize=\tiny, bgcolor=gray!10, escapeinside=||]{java}
    public class MyGame implements ApplicationListener {
        private GameManager manager;
        private AudioManager audio; // <--- BARIS BARU 8
        private GameScreen screen;
        
        public void create() {
            this.manager = new GameManager();
            this.audio = new AudioManager(); // <--- BARIS BARU 9
            this.screen = new GameScreen(this.manager, this.audio); // <--- BARIS BARU 10
        }
    }
    \end{minted}
    \end{column}
    \end{columns}
    \end{spacing}    
\end{frame}

\begin{frame}[fragile]
    \frametitle{Pertanyaan}
    \footnotesize
    Jawablah pertanyaan-pertanyaan berikut secara berurutan:
    
    \begin{enumerate}
        \item \textbf{(C1 - Mengingat)}: Jelaskan perbedaan fundamental antara paradigma \textbf{Game Loop} (stateful, siklus) dan \textbf{Request-Response} (stateless, linear)!
        \item \textbf{(C1 - Mengingat)}: Berdasarkan konteks "Fase Perakitan" vs "Fase Operasi", jelaskan perbedaan tanggung jawab antara \texttt{create()} dan \texttt{render()}!
        \item \textbf{(C1 - Mengingat)}: Apa itu masalah ``\textit{Object Drilling}'' yang diilustrasikan oleh "KODE SETELAH PERUBAHAN"?
        \item \textbf{(C3 - Menerapkan)}: Tunjukkan \textbf{semua baris baru} di kelas \texttt{GameScreen} (kelas perantara) yang ditambahkan \textbf{hanya} untuk melayani kebutuhan kelas \texttt{Player}!
        \item \textbf{(C4 - Menganalisis)}: Mengapa fakta bahwa kelas \texttt{GameScreen} (sang perantara) harus diubah ini adalah tanda desain yang ``rapuh'' dan melanggar modularitas?
        \item \textbf{(C6 - Mencipta)}: \textbf{Tulis ulang (refactor)} ketiga kelas (\texttt{MyGame}, \texttt{GameScreen}, \texttt{Player}) menggunakan \textbf{Singleton Pattern} untuk melepaskan ``Mandor'' dan ``Perantara'' dari tanggung jawab ``\textit{drilling}'' ini!
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (1/3)}
    \footnotesize
    \begin{enumerate}
        \item \textbf{(C1 - Paradigma)}:
        \begin{itemize}
            \item \textbf{Request-Response (Web):} Pasif, stateless, linear. Server menunggu \textit{request}, memprosesnya, mengirim \textit{response}, lalu kembali menunggu.
            \item \textbf{Game Loop (Game):} Aktif, stateful, siklus. Aplikasi berjalan terus-menerus dalam siklus (Input-Update-Render) untuk mengelola \textit{state} di memori.
        \end{itemize}
        
        \item \textbf{(C1 - Lifecycle)}:
        \begin{itemize}
            % Menggunakan karakter biasa jika emoji menyebabkan masalah font
            \item \textbf{create()}: "Fase Perakitan". Dipanggil \textbf{satu kali} di awal untuk inisialisasi, \textit{load} aset, dan konstruksi \textit{object graph}.
            \item \textbf{render()}: "Fase Operasi". Dipanggil \textbf{terus-menerus} (~60x per detik) untuk mengeksekusi game loop (logika dan gambar).
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (2/3)}
    \footnotesize
    \begin{enumerate}
        \setcounter{enumi}{2} % Melanjutkan nomor dari slide sebelumnya
        
        \item \textbf{(C1 - Object Drilling)}:
        \begin{itemize}
            \item Praktik di mana sebuah kelas perantara (\texttt{GameScreen}) dipaksa untuk menerima, menyimpan, dan meneruskan dependensi (\texttt{AudioManager}) yang tidak ia gunakan sama sekali, hanya untuk "mengoper"-nya ke kelas lain (\texttt{Player}).
        \end{itemize}
        
        \item \textbf{(C3 - Baris yang Ditambahkan ke \texttt{GameScreen})}:
        \begin{itemize}
            \item \textbf{Baris Baru 5}: \texttt{private AudioManager audio;}
            \item \textbf{Baris Baru 6}: \texttt{public GameScreen(..., AudioManager audio)} (dan isi di dalamnya)
            \item \textbf{Baris Baru 7}: \texttt{this.player = new Player(..., this.audio);}
        \end{itemize}
        
        \item \textbf{(C4 - Analisis "Rapuh")}
        \begin{itemize}
            \item Karena \textbf{perubahan pada kebutuhan \texttt{Player} menyebabkan "kerusakan" pada \texttt{GameScreen}} (dan juga \texttt{MyGame}).
            \item \texttt{GameScreen} (perantara) seharusnya tidak perlu tahu dependensi internal dari \texttt{Player}. Ini melanggar prinsip modularitas dan \textit{encapsulation}. \texttt{GameScreen} kini "rapuh" karena akan patah lagi jika \texttt{Player} butuh dependensi baru.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (3/3)}
    \footnotesize
    \begin{spacing}{0.85}
    \begin{enumerate}
        \setcounter{enumi}{5} % Melanjutkan nomor dari slide sebelumnya
        
        \item \textbf{(C6 - Refactor Menggunakan Singleton)}:
        \begin{itemize}
            \item \textbf{Asumsi:} \texttt{GameManager} dan \texttt{AudioManager} diubah menjadi Singleton (memiliki \texttt{getInstance()}).
            
            \textbf{Refactor \texttt{Player.java}:}
    \begin{minted}[fontsize=\tiny, bgcolor=gray!10]{java}
    public class Player {
        public Player() { } // Constructor bersih
        public void collectCoin() {
            GameManager.getInstance().addScore(10);
            AudioManager.getInstance().playSound("coin");
        }
    }
    \end{minted}
            \textbf{Refactor \texttt{GameScreen.java}:}
    \begin{minted}[fontsize=\tiny, bgcolor=gray!10]{java}
    public class GameScreen {
        private Player player;
        // Tidak perlu lagi menerima dependensi
        public GameScreen() {
            this.player = new Player();
        }
    }
    \end{minted}
            \textbf{Refactor \texttt{MyGame.java}:}
    \begin{minted}[fontsize=\tiny, bgcolor=gray!10]{java}
    public class MyGame implements ApplicationListener {
        private GameScreen screen;
        public void create() {
            // Tidak perlu lagi membuat manajer
            this.screen = new GameScreen(); 
        }
    }
    \end{minted}
        \end{itemize}
    \end{enumerate}
    \end{spacing}
\end{frame}

% ===================================================
% STUDI KASUS 3 (SK 3)
% ===================================================
\section{Studi Kasus A.2}
\begin{frame}
    \frametitle{Konteks Debat Desain}
    \footnotesize
    
    Setelah berhasil menyelesaikan masalah ``\textit{Object Drilling}'' menggunakan Singleton Pattern di Studi Kasus A.1, rekan Anda, Budi, merasa sangat puas. Namun, Anda menyadari bahwa solusi ini mungkin melanggar dua prinsip desain fundamental:
    
    \begin{itemize}
        \item \textbf{Single Responsibility Principle (SRP):} Menyatakan bahwa sebuah kelas seharusnya hanya memiliki \textbf{satu alasan untuk berubah} (satu tanggung jawab utama).
        \item \textbf{Testability (via Unit Testing):} Kemampuan untuk menguji sebuah ``unit'' (kelas/metode) secara \textbf{terisolasi} dari dependensi eksternalnya untuk memverifikasi perilakunya. Desain yang baik memfasilitasi pengujian terisolasi ini.
    \end{itemize}
    
    \medskip
    Perhatikan argumen Budi berikut, yang fokus pada kemudahan akses:

    \medskip
    \begin{beamercolorbox}[rounded=true, shadow=true]{block body}
        \centering
        \textit{"Singleton pattern itu hebat! \texttt{MyGame} (root object) kita jadi bersih! Kelas \texttt{Player} saya bisa langsung panggil \texttt{GameManager.getInstance()} kapan saja. Ini membuat kode jauh lebih \textbf{mudah}!"}
        \par
        \vspace{0.3cm}
        \textbf{-- Budi, Junior Programmer}
    \end{beamercolorbox}
    
    \begin{alertblock}{Tantangan Anda}
    Meskipun Singleton memang mempermudah akses global, analisislah apakah ``kemudahan'' ini sepadan dengan potensi pelanggaran SRP dan dampaknya pada \textit{testability}.
    \end{alertblock}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Pertanyaan}
    \footnotesize
    Berdasarkan konteks desain dan debat dengan Budi, bangunlah analisis kritis Anda:
    
    \begin{enumerate}
        % --- PERTANYAAN REVISI DI SINI ---
        \item \textbf{(C2 - Memahami)}: Jelaskan mengapa prinsip SRP ini penting? Apa \textbf{manfaat} utama yang ingin dicapai dengan mematuhi SRP?
        
        \item \textbf{(C2 - Memahami)}: Jelaskan \textbf{dua tanggung jawab berbeda} yang diemban oleh kelas Singleton (seperti \texttt{GameManager}) sehingga ia dapat dianggap melanggar SRP!
        
        \item \textbf{(C3 - Menerapkan)}: Perhatikan implementasi Singleton \texttt{GameManager} dari slide materi. Tunjukkan bagian kode mana yang bertanggung jawab untuk \textit{logika bisnis} (misal: skor) dan bagian mana yang bertanggung jawab untuk \textit{manajemen siklus hidup} (memastikan satu instansi)!
        
        \item \textbf{(C1 - Mengingat)}: Apa tujuan utama dari \textbf{\textit{unit testing}} (menguji secara terisolasi)?
        
        \item \textbf{(C4 - Menganalisis)}: Bagaimana ``Dependensi Tersembunyi'' (\textit{Hidden Dependency}) yang diperkenalkan oleh Singleton membuat kode \textbf{lebih sulit dipahami} dan \textbf{dimodifikasi} di masa depan?
        
        \item \textbf{(C5 - Mengevaluasi)}: \textbf{Evaluasi} klaim Budi bahwa Singleton membuat kode ``lebih mudah''! Berikan dua \textbf{argumen tandingan (\textit{counter-arguments})} yang kuat, berdasarkan prinsip-prinsip desain perangkat lunak dan praktik \textit{testing} yang baik, untuk menjelaskan potensi \textbf{konsekuensi negatif jangka panjang} dari penggunaan Singleton!
    \end{enumerate}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (Bagian 1/3)}
    \footnotesize
    
    \begin{enumerate}
        \item \textbf{(C2 - Manfaat SRP)}:
        \begin{itemize}
            \item \textbf{Manfaat Utama:} Meningkatkan \textbf{kohesi} (komponen terkait erat berada dalam satu kelas) dan mengurangi \textbf{coupling} (ketergantungan antar kelas).
            \item \textbf{Dampak:} Kode menjadi lebih \textbf{mudah dipahami}, \textbf{dipelihara}, dan \textbf{diubah} karena perubahan pada satu tanggung jawab tidak secara langsung memengaruhi tanggung jawab lain di kelas yang berbeda. Mengurangi risiko \textit{bug} saat modifikasi.
        \end{itemize}
    
        \item \textbf{(C2 - Pelanggaran SRP)}:
        \begin{itemize}
            \item Kelas Singleton memiliki \textbf{dua tanggung jawab}:
            \begin{enumerate}
                \item \textbf{Logika Bisnis/Domain:} Mengelola \textit{state} atau fungsionalitas inti aplikasi (misal: skor, posisi pemain).
                \item \textbf{Manajemen Siklus Hidup:} Memastikan bahwa hanya ada satu instansi dari kelas tersebut yang dibuat (\textit{creational responsibility}, logika \texttt{getInstance()}).
            \end{enumerate}
        \end{itemize}
        
        \item \textbf{(C3 - Penerapan Tanggung Jawab)}:
        \begin{itemize}
            \item \textbf{Logika Bisnis:} Atribut seperti \texttt{score} dan metode seperti \texttt{addScore()}, \texttt{getScore()}.
            \item \textbf{Manajemen Siklus Hidup:} Atribut \texttt{private static instance}, \texttt{private constructor}, dan metode \texttt{public static getInstance()}.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (Bagian 2/3)}
    \footnotesize
    
    \begin{enumerate}
        \setcounter{enumi}{3} % Melanjutkan nomor dari slide sebelumnya
        \item \textbf{(C1 - Unit Testing)}:
        \begin{itemize}
            \item Tujuannya adalah untuk \textbf{menguji satu "unit"} (kelas atau metode) secara \textbf{terisolasi} dari dependensi eksternalnya untuk memverifikasi perilakunya secara independen.
        \end{itemize}
        
        \item \textbf{(C4 - Analisis Dependensi Tersembunyi)}:
        \begin{itemize}
            \item \textbf{Sulit Dipahami:} Saat membaca kelas \texttt{Player}, kita tidak bisa langsung melihat dari \textit{constructor}-nya bahwa ia membutuhkan \texttt{GameManager}. Dependensinya "tersembunyi" di dalam metode \texttt{collectCoin()}. Ini mengurangi kejelasan (\textit{clarity}) kode.
            \item \textbf{Sulit Dimodifikasi:} Jika di masa depan kita ingin \texttt{Player} menggunakan \textit{versi lain} dari \texttt{GameManager} (misalnya, \texttt{MockGameManager} untuk testing, atau \texttt{MultiplayerGameManager}), kita tidak bisa dengan mudah "menyuntikkan" versi lain tersebut karena \texttt{Player} terikat erat (\textit{hardcoded}) ke pemanggilan \texttt{GameManager.getInstance()}.
        \end{itemize}
    \end{enumerate}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (Bagian 3/3)}
    \footnotesize
    
    \begin{enumerate}
        \setcounter{enumi}{5} % Melanjutkan nomor dari         sebelumnya
        \item \textbf{(C5 - Evaluasi / Argumen Tandingan)}:
        \begin{itemize}
            % Perbaikan: Mengganti & dengan \&
            \item \textbf{Argumen 1 (Pelanggaran SRP \& Maintainability):} Klaim "mudah" Budi bersifat jangka pendek. Jangka panjang, Singleton menyulitkan pemeliharaan (\textit{maintainability}). Karena melanggar SRP (menggabungkan logika bisnis dan siklus hidup), \texttt{GameManager} menjadi sulit diubah. Perubahan pada salah satu tanggung jawab dapat memengaruhi yang lain. Selain itu, dependensi tersembunyi (dianalisis di C4) membuat kode sulit dipahami dan dimodifikasi saat kebutuhan berubah.
            \item \textbf{Argumen 2 (Masalah Testability):} "Kemudahan" akses global secara signifikan merusak \textit{testability}. Tujuan utama \textit{unit testing} (menguji secara terisolasi) menjadi sulit dicapai. Kelas seperti \texttt{Player} tidak dapat diuji tanpa secara otomatis melibatkan \textit{state} global dari Singleton \texttt{GameManager}. Ini memaksa pengujian menjadi \textit{integration test}, yang lebih kompleks dan rapuh, bertentangan dengan praktik \textit{testing} yang baik.
        \end{itemize}
    \end{enumerate}

\end{frame}

% ===================================================
% STUDI KASUS 1 (REVISI KONTEKS & STRUKTUR)
% Slide Konteks Dipecah Menjadi 3
% ===================================================
\section{Studi Kasus B.1}
\begin{frame}[t,fragile]
    \frametitle{Konteks - Paradigma Game Loop (1/4)}
    \small
    Studi kasus ini berfokus pada \textit{bug} klasik akibat kesalahpahaman terhadap \textbf{Paradigma Game Loop}.

    Ingat kembali perbedaan fundamental:
    \begin{itemize}
        \item \textbf{Request-Response (Web):} Pasif, stateless, linear. Tidak cocok untuk simulasi berkelanjutan karena tidak menjamin eksekusi yang konsisten terhadap waktu.
        \item \textbf{Game Loop (Game):} Aktif, stateful, siklus (Input-Update-Render). Diperlukan karena game butuh simulasi real-time yang state-nya terus berubah dan konsisten secara temporal.
    \end{itemize}

    \medskip
    Tujuan utama dari \textit{game loop} adalah untuk menjamin \textbf{Konsistensi Temporal}â€”sebuah lompatan karakter harus memakan waktu 1 detik yang sama di komputer 30 FPS maupun 120 FPS.

\end{frame}

\begin{frame}[fragile]
    \frametitle{Konteks - Pemisahan Tugas (2/4)}
    \small
    Untuk mencapai Konsistensi Temporal, Paradigma Game Loop secara fundamental \textbf{memisahkan (decouple)} dua tanggung jawab utama dalam setiap siklusnya:

    \begin{itemize}
        \item \textbf{Fase Update \textit{(Logic)} [Logika]:}
        \begin{itemize}
            \item \textbf{Tugas:} Mengubah state game (posisi, skor, timer, AI, fisika) berdasarkan input dan waktu.
            \item \textbf{Prinsip:} Harus berjalan konsisten secara logis. Menggunakan \texttt{deltaTime} (\texttt{delta}) agar perubahan state independen dari kecepatan hardware (FPS).
            \item \textbf{Pelaksana Umum:} CPU.
        \end{itemize}
        \item \textbf{Fase Render \textit{(Graphics)} [Grafis]:}
        \begin{itemize}
            \item \textbf{Tugas:} Membaca state (yang sudah final dari fase Update) dan menampilkannya ke layar.
            \item \textbf{Prinsip:} Harus berjalan secepat mungkin. Idealnya bersifat \textit{read-only} (tidak mengubah state).
            \item \textbf{Pelaksana Umum:} GPU.
        \end{itemize}
    \end{itemize}
    Pemisahan ini krusial agar logika game tidak terpengaruh fluktuasi kecepatan rendering.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Konteks - Kode Bermasalah (3/4)}
    \footnotesize
    \begin{alertblock}{Analisis Kode}
    Seorang junior programmer, yang belum memahami pemisahan ini, menempatkan logika \textit{state update} (\texttt{updateComboTimer}) di dalam fase \textit{rendering} (\texttt{draw}). Kita akan menganalisis dampaknya. \texttt{GameManager} berikut digunakan sebagai Singleton.
    \end{alertblock}
    
\begin{minted}[fontsize=\tiny, bgcolor=gray!10, escapeinside=||]{java}
// GameManager.java - Bertugas menyimpan state global
public class GameManager {
    private static GameManager instance;
    private int score;
    private float comboTimer = 0.0f;
    private int comboMultiplier = 1;
    // ... (constructor private & getInstance() tidak ditampilkan) ...

    public int getDisplayScore() { return score * comboMultiplier; }
    public void addScore(int s) { score += s; }
    public void registerHit() { /* ... */ }
    
    // Metode ini seharusnya dipanggil di FASE UPDATE, 
    // bukan oleh komponen rendering seperti HUD.
    public void updateComboTimer(float delta) {
        if (this.comboTimer > 0) {
            this.comboTimer -= delta;
            if (this.comboTimer <= 0) this.comboMultiplier = 1; 
        }
    }
}
\end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Konteks - Kode Bermasalah (4/4)}
    \footnotesize
    \begin{spacing}{0.85}
    Berikut kelas \texttt{HUD} yang ditulis olehnya. Perhatikan di mana ia memanggil \texttt{updateComboTimer}.

\begin{minted}[fontsize=\tiny, bgcolor=gray!10, escapeinside=||]{java}
// HUD.java - Bertugas menampilkan informasi ke layar
public class HUD {
    // Diasumsikan HUD punya referensi ke objek Font, dll.
    // Inisialisasi aset grafis (Font, Texture) idealnya 
    // dilakukan di constructor atau metode create().
    // private Font font; 
    
    public HUD() { 
        // font = new Font(...); 
    }

    // Metode ini bagian dari FASE RENDER.
    // Seharusnya HANYA membaca state dan menggambar.
    public void draw(float delta) { 
        // Mengambil instance Singleton GameManager
        GameManager gm = GameManager.getInstance(); // <--- BARIS 7 
        
        // KESALAHAN FATAL: Memanggil logika update state
        // di dalam fase render!
        gm.updateComboTimer(delta); // <--- BARIS 10 

        // Membaca state untuk digambar (Ini OK)
        int displayScore = gm.getDisplayScore();
        // font.draw("Score: " + displayScore, x, y); 
        if (gm.comboMultiplier > 1) {
            // font.draw("COMBO x" + gm.comboMultiplier, x, y+20); 
        }
    }
}
\end{minted}
    \end{spacing}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Pertanyaan}
    \footnotesize
    \begin{spacing}{0.85}
    Jawablah pertanyaan-pertanyaan berikut secara berurutan:

    \begin{enumerate}
        % REVISI Q1: Fokus pada *mengapa* Game Loop diperlukan
        \item \textbf{(C2 - Memahami)}: Mengapa paradigma \textbf{Request-Response} (yang state-less dan linear) \textbf{tidak cocok} untuk game interaktif real-time, sehingga memerlukan paradigma \textbf{Game Loop}?
        % REVISI Q2: Fokus pada *contoh penerapan* lifecycle
        \item \textbf{(C3 - Menerapkan)}: Mengacu pada konsep umum \textit{lifecycle} LibGDX, berikan contoh \textbf{satu tugas spesifik} yang seharusnya dilakukan saat menginisialisasi \texttt{HUD} (misal, di \texttt{create()} atau constructor), dan \textbf{satu tugas spesifik} yang dilakukan berulang kali di dalam \texttt{draw()} saat \texttt{HUD} beroperasi!
        \item \textbf{(C2 - Memahami)}: Mengapa \texttt{delta} (delta time) krusial untuk \textbf{konsistensi temporal}? Apa konsekuensi jika \texttt{updateComboTimer} tidak dikalikan \texttt{delta}?
        \item \textbf{(C1 - Mengingat)}: Berdasarkan konteks pemisahan tugas Game Loop, jelaskan kembali perbedaan \textbf{tanggung jawab} antara Fase Update (Logika) dan Fase Render (Grafis)!
        \item \textbf{(C3 - Menerapkan)}: Tunjukkan di \textbf{baris kode} mana dari kelas \texttt{HUD} prinsip pemisahan fundamental ini dilanggar!
        \item \textbf{(C1 - Mengingat)}: Apa yang dimaksud dengan "Dependensi Tersembunyi" (\textit{Hidden Dependency}) dalam konteks Singleton?
        \item \textbf{(C3 - Menerapkan)}: Tunjukkan di \textbf{baris kode} mana kelas \texttt{HUD} mengambil dependensi tersembunyinya ke \texttt{GameManager}!
        \item \textbf{(C5 - Mengevaluasi)}: \textbf{Evaluasi!} Mengapa pelanggaran pemisahan (Soal \#5) membuat masalah Dependensi Tersembunyi (Soal \#7) menjadi \textit{jauh lebih buruk}, terutama dari sudut pandang \textit{unit testing}?
    \end{enumerate}
    \end{spacing}
\end{frame}

% --- Kunci Jawaban SK 1 Dipecah Menjadi 3 Slide ---

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (Bagian 1/3 - Fondasi)}
    \footnotesize
    \begin{spacing}{0.85}
    \begin{enumerate}
        % REVISI A1
        \item \textbf{(C2 - Memahami Paradigma)}:
        \begin{itemize}
            \item \textbf{Request-Response tidak cocok karena:} Sifatnya pasif (menunggu request), stateless (tidak ingat state), dan linear (request-response). Game butuh proses aktif, stateful, dan siklus kontinu untuk simulasi real-time.
            \item \textbf{Game Loop diperlukan karena:} Memungkinkan pengelolaan state yang terus berubah dan eksekusi logika/render secara berkelanjutan, independen dari input user, serta menjaga konsistensi temporal.
        \end{itemize}
        
        % REVISI A2
        \item \textbf{(C3 - Menerapkan Lifecycle)}:
        \begin{itemize}
            \item \textbf{Contoh Tugas Inisialisasi \texttt{HUD} (di \texttt{create}/constructor):} Membuat instance \texttt{Font}, me-load \texttt{Texture} untuk background, menentukan posisi awal teks skor. (Dilakukan sekali).
            \item \textbf{Contoh Tugas Operasi \texttt{HUD} (di \texttt{draw}):} Mengambil nilai \texttt{score} terbaru dari \texttt{GameManager}, memformat string skor, menggambar string tersebut ke layar menggunakan \texttt{Font} pada posisi yang sudah ditentukan. (Dilakukan berulang kali per frame).
        \end{itemize}

        \item \textbf{(C2 - Delta Time)}:
        \begin{itemize}
            \item \texttt{delta} adalah waktu (detik) sejak frame terakhir. Krusial agar logika game (gerakan, timer) berjalan \textbf{konsisten} secara waktu nyata, tidak terpengaruh kecepatan FPS hardware.
            \item \textbf{Tanpa delta:} Logika menjadi tidak adil/konsisten. Di komputer cepat (FPS tinggi), timer habis lebih cepat; di komputer lambat (FPS rendah), timer habis lebih lambat.
        \end{itemize}
    \end{enumerate}
    \end{spacing}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (Bagian 2/3 - Analisis)}
    \footnotesize
    \begin{enumerate}
        \setcounter{enumi}{3} % Melanjutkan nomor
        \item \textbf{(C1 - Update/Render)}:
        \begin{itemize}
            \item \textbf{Fase Update (Logika):} Bertanggung jawab untuk \textbf{mengubah/menulis} \textit{state} secara konsisten berdasarkan input dan waktu (\texttt{delta}).
            \item \textbf{Fase Render (Grafis):} Bertanggung jawab untuk \textbf{membaca} \textit{state} yang sudah final dan menggambarkannya. Idealnya \textit{read-only}.
        \end{itemize}

        \item \textbf{(C3 - Pelanggaran Pemisahan)}:
        \begin{itemize}
            \item Terjadi pada \textbf{Baris 10}: \texttt{gm.updateComboTimer(delta);}.
            \item \textit{Justifikasi:} Kode ini melakukan \textit{state update} (logika) di dalam metode \texttt{draw()} yang seharusnya hanya untuk \textit{rendering} (grafis).
        \end{itemize}
        
        \item \textbf{(C1 - Dependensi Tersembunyi)}:
        \begin{itemize}
            \item Kelemahan Singleton di mana kelas pengguna (misal: \texttt{HUD}) dapat memanggil Singleton (\texttt{GameManager.getInstance()}) secara internal, tanpa mendeklarasikan kebutuhan ini secara eksplisit di \textit{constructor}-nya. Ketergantungannya tidak terlihat dari luar.
        \end{itemize}

        \item \textbf{(C3 - Pengambilan Dependensi)}:
        \begin{itemize}
             \item Terjadi pada \textbf{Baris 7}: \texttt{GameManager gm = GameManager.getInstance();}.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[t,fragile]
    \frametitle{Kunci Jawaban (Bagian 3/3 - Evaluasi)}
    \footnotesize
    \begin{enumerate}
        \setcounter{enumi}{7} % Melanjutkan nomor
        \item \textbf{(C5 - Evaluasi)}:
        \begin{itemize}
            \item \textbf{Masalah Utama:} Pelanggaran pemisahan (Soal \#5) membuat \texttt{HUD} kini memiliki \textbf{tanggung jawab ganda} (menggambar UI \textit{dan} memicu logika gameplay), melanggar SRP.
            \item \textbf{Dampak pada Testing:} Ini memperburuk masalah \textit{unit testing} yang sudah ada akibat dependensi tersembunyi (Soal \#7). Untuk menguji logika \texttt{updateComboTimer()}, kita tidak bisa lagi menguji \texttt{GameManager} secara terisolasi.
            \item \textbf{Skenario Test Buruk:} Kita terpaksa harus membuat instansi \texttt{HUD} (yang mungkin kompleks) dan memanggil metode \texttt{draw()}-nya, hanya untuk memicu sebuah logika \textit{gameplay} yang seharusnya independen dari UI. Ini menciptakan \textit{tight coupling} antara UI dan Logika, membuat pengujian menjadi sulit, tidak intuitif, dan rapuh.
        \end{itemize}
    \end{enumerate}
\end{frame}


% ===================================================
% STUDI KASUS 4 (REVISI KONTEKS & STRUKTUR)
% Slide Konteks Dipecah Menjadi 3
% ===================================================
\section{Studi Kasus B.2}
\begin{frame}[fragile]
    \frametitle{Konteks - Singleton \& Multithreading (1/3)}
    \footnotesize % Tambahan
    \begin{spacing}{0.85} % Tambahan
    Paradigma Game Loop mengharuskan pengelolaan \textit{state} game (skor, posisi, dll.) secara terpusat agar konsisten antar frame dan antar komponen.

    \medskip
    Sebuah pendekatan umum untuk mengelola \textit{state} terpusat ini adalah dengan menggunakan kelas manajer khusus, contohnya \texttt{GameManager}. Tantangan arsitektural kemudian muncul: bagaimana menyediakan akses ke manajer ini dari berbagai komponen game (Player, HUD, AI, dll.) secara efisien dan terkelola?

    \medskip
    Pola desain \textbf{Singleton} sering dipilih untuk mengatasi masalah akses global ini, menggantikan mekanisme seperti ``\textit{Object Drilling}''. Namun, implementasi standarnya, terutama yang menggunakan \textbf{"Lazy Initialization"}, memiliki kelemahan kritis saat beroperasi dalam lingkungan \textit{multithreading}.
    \end{spacing} % Tambahan
\end{frame}

\begin{frame}[fragile]
    \frametitle{Konteks - Kode Lazy Initialization (2/3)}
    \footnotesize % Tambahan
    \begin{spacing}{0.85} % Tambahan
    Perhatikan implementasi \textbf{"Lazy Initialization"} standar berikut. Tujuannya adalah menunda pembuatan objek \texttt{GameManager} sampai ia benar-benar dibutuhkan pertama kali (\textit{on-demand creation}) untuk menghemat sumber daya startup.

    \begin{minted}[fontsize=\tiny, bgcolor=gray!10]{java}
// GameManager.java - Implementasi Lazy Initialization Naif
public class GameManager {
    // 1. Instansi statis, awalnya null
    private static GameManager instance;
    private int score;

    // 2. Constructor private
    private GameManager() { this.score = 0; }

    // 3. Metode akses global (Lazy Initialization NAIF)
    public static GameManager getInstance() {
        // Cek apakah sudah dibuat
        if (instance == null) {         // <--- TITIK A (Pengecekan)
            // Jika belum, buat instance baru
            instance = new GameManager(); // <--- TITIK B (Pembuatan)
        }
        // Kembalikan instance
        return instance;
    }
    // ... (metode addScore, dll) ...
}
    \end{minted}
    \textit{Catatan: Kode ini sengaja disajikan dalam bentuk naif (tanpa \texttt{synchronized} atau DCL) untuk analisis.}
    \end{spacing} % Tambahan
\end{frame}

\begin{frame}[fragile]
    \frametitle{Konteks - Tantangan Multithreading (3/3)}
    \footnotesize % Tambahan
    \begin{spacing}{0.85} % Tambahan
     % PERBAIKAN: Escape karakter &
     \begin{alertblock}{Tantangan: Multithreading dan Race Condition}
    Game modern sering menggunakan \textit{multithreading} (misal: thread Fisika, AI, Jaringan, UI) untuk performa.

    \medskip
    Masalah muncul jika dua \textit{thread} memanggil \texttt{getInstance()} \textbf{secara bersamaan} saat \texttt{instance} masih \textit{null}.

    \medskip
    Operasi antara pengecekan (Titik A) dan pembuatan (Titik B) \textbf{tidak atomic}. Ini bisa menyebabkan \textbf{\textit{Race Condition}}: kedua thread mungkin lolos pengecekan A, lalu keduanya mengeksekusi B, sehingga membuat dua instansi berbeda dan melanggar prinsip Singleton.
    \end{alertblock}

    \vspace{0.5cm}
    Tugas kita adalah menganalisis \textit{race condition} ini dan mencari cara untuk membuat \texttt{getInstance()} menjadi \textit{thread-safe}.
    \end{spacing} % Tambahan
\end{frame}

\begin{frame}[fragile]
    \frametitle{Pertanyaan}
    \footnotesize % Tambahan
    \begin{spacing}{0.85} % Tambahan
    Berdasarkan kode dan skenario \textit{multithreading} dari slide sebelumnya:

    \begin{enumerate}
        \item \textbf{(C1 - Mengingat)}: Apa tujuan/manfaat utama dari \textit{lazy initialization} dalam Singleton?
        \item \textbf{(C2 - Memahami)}: Jelaskan \textbf{langkah demi langkah} skenario \textit{race condition} di mana Thread A dan Thread B memanggil \texttt{getInstance()} (versi naif) secara bersamaan, dan menyebabkan \textbf{dua instansi} \texttt{GameManager} tercipta! (Gunakan Titik A dan Titik B sebagai referensi).
        \item \textbf{(C6 - Mencipta)}: Tuliskan \textbf{satu cara} untuk memodifikasi metode \texttt{getInstance()} (versi naif) agar menjadi \textit{thread-safe}, beserta penjelasan singkat mengenai \textit{trade-off} (kelebihan/kekurangan) dari solusi Anda.
    \end{enumerate}
    \end{spacing} % Tambahan
\end{frame}

% --- Kunci Jawaban SK 4 Dipecah Menjadi 4 Slide ---

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (Bagian 1/5 - Lazy Init \& Race Condition)}
    \footnotesize % Tambahan
    \begin{spacing}{0.85} % Tambahan
    \begin{enumerate}
        \item \textbf{(C1 - Lazy Initialization)}:
        \begin{itemize}
            \item \textbf{Tujuan:} Menunda pembuatan instansi Singleton sampai saat ia pertama kali dibutuhkan (\textit{on-demand creation}).
            \item \textbf{Manfaat:} Menghemat sumber daya (memori/waktu) saat startup jika instansi "berat" dan mungkin tidak selalu digunakan.
        \end{itemize}

        \item \textbf{(C2 - Skenario Race Condition - Versi Naif)}:
        \begin{itemize}
            \item \textbf{Langkah 1:} Thread A masuk \texttt{getInstance()}, lolos cek \texttt{if (instance == null)} (Titik A).
            \item \textbf{Langkah 2:} CPU menjeda Thread A \textbf{sebelum} eksekusi Titik B.
            \item \textbf{Langkah 3:} Thread B masuk, \textbf{juga lolos} cek (Titik A) karena \texttt{instance} masih null.
            \item \textbf{Langkah 4:} Thread B mengeksekusi Titik B (\texttt{new GameManager()}), menyimpan ke \texttt{instance}.
            \item \textbf{Langkah 5:} Thread A kembali berjalan. Ia \textbf{tidak cek ulang}, langsung eksekusi Titik B, membuat instansi \textbf{kedua} dan menimpa \texttt{instance}.
            \item \textbf{Hasil:} Dua instansi dibuat, melanggar prinsip Singleton.
        \end{itemize}
    \end{enumerate}
    \end{spacing} % Tambahan
\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (2/5 - Solusi 1: Synchronized Method)}
    \footnotesize % Tambahan
    \begin{spacing}{0.85} % Tambahan
    \begin{enumerate}
        \setcounter{enumi}{2} % Melanjutkan nomor
        \item \textbf{(C6 - Solusi Thread-Safe Alternatif)}: (Jawaban bagian ini dipecah ke beberapa slide)

        \textbf{Solusi 1: Metode Synchronized}
        \begin{itemize}
            \item \textit{Implementasi:} Menambahkan \texttt{synchronized} pada \textit{signature} metode.
            \item \textit{Cara Kerja:} Memastikan hanya satu thread yang bisa mengeksekusi seluruh metode \texttt{getInstance()} pada satu waktu (mutual exclusion). Mencegah race condition karena thread kedua harus menunggu thread pertama selesai (termasuk pembuatan instansi jika perlu) sebelum bisa masuk.
            \item \textit{Trade-off:} Sederhana implementasinya, tapi \textbf{kurang efisien}. \textit{Locking} (\texttt{synchronized}) terjadi pada \textbf{setiap} pemanggilan \texttt{getInstance()}, bahkan setelah instansi sudah dibuat dan \textit{locking} tidak lagi diperlukan. Ini bisa menjadi \textit{bottleneck} performa signifikan jika \texttt{getInstance()} sering dipanggil.
        \end{itemize}
    \end{enumerate}
\begin{minted}[fontsize=\tiny, bgcolor=gray!10]{java}
public class GameManager {
    private static GameManager instance;
    // ... constructor private ...

    // Solusi 1: Synchronized pada seluruh metode
    public static synchronized GameManager getInstance() {
        if (instance == null) {
            instance = new GameManager();
        }
        return instance;
    }
}
\end{minted}
    \end{spacing} % Tambahan
\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (3/5 - Solusi 2: Eager Initialization)}
    \footnotesize % Tambahan
    \begin{spacing}{0.85} % Tambahan
    \begin{enumerate}
        \setcounter{enumi}{2} % Melanjutkan nomor
        \item \textbf{(C6 - Solusi Thread-Safe Alternatif)}:

        \textbf{Solusi 2: Eager Initialization}
        \begin{itemize}
             \item \textit{Implementasi:} Membuat instansi langsung saat atribut statis dideklarasikan (menggunakan \texttt{final}).
             \item \textit{Cara Kerja:} Instansiasi terjadi hanya sekali saat kelas di-load oleh ClassLoader JVM. Proses ClassLoading di JVM dijamin \textit{thread-safe} secara inheren. Tidak ada \textit{race condition} pada \texttt{getInstance()}.
             \item \textit{Trade-off:} Paling simpel dan \textbf{paling efisien saat akses} (\texttt{getInstance()} hanya return referensi), tapi \textbf{kehilangan manfaat \textit{lazy loading}}. Instansi dibuat saat startup aplikasi, meskipun mungkin tidak pernah atau baru akan digunakan nanti. Tidak cocok jika pembuatan instansi sangat mahal dan tidak selalu dibutuhkan.
        \end{itemize}
    \end{enumerate}
\begin{minted}[fontsize=\tiny, bgcolor=gray!10]{java}
public class GameManager {
    // Solusi 2: Instansi dibuat langsung (Eager)
    private static final GameManager instance = new GameManager();
    private int score;

    private GameManager() { this.score = 0; }

    // getInstance() menjadi sangat simpel dan cepat
    public static GameManager getInstance() {
        return instance;
    }
    // ...
}
\end{minted}
    \end{spacing} % Tambahan
\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (4/5 - Solusi 3: DCL)}
    \footnotesize % Tambahan
    \begin{spacing}{0.85} % Tambahan
    \begin{enumerate}
        \setcounter{enumi}{2} % Melanjutkan nomor
        \item \textbf{(C6 - Solusi Thread-Safe Alternatif)}:

        \textbf{Solusi 3: Double-Checked Locking (DCL)}
         \begin{itemize}
             \item \textit{Implementasi:} Menggunakan \texttt{volatile} pada variabel \texttt{instance} dan blok \texttt{synchronized} hanya di sekitar pembuatan instansi, didahului dan diikuti oleh pengecekan null.
             \item \textit{Cara Kerja:} Pengecekan null pertama (di luar blok sync) menghindari overhead \textit{locking} setelah instansi dibuat. Jika null, baru masuk blok sync. Pengecekan null kedua (di dalam blok sync) menangani \textit{race condition} jika dua thread lolos cek pertama bersamaan. \texttt{volatile} memastikan visibilitas perubahan \texttt{instance} antar thread.
             \item \textit{Trade-off:} Mencoba \textbf{menggabungkan manfaat} lazy loading dan efisiensi akses setelah dibuat. Lebih \textbf{optimal} daripada metode synchronized, tapi \textbf{jauh lebih kompleks} implementasinya dan rawan kesalahan (lupa \texttt{volatile} atau struktur cek ganda yang salah bisa membuatnya gagal).
         \end{itemize}
    \end{enumerate}
    \end{spacing} % Tambahan
\end{frame}

\begin{frame}[fragile]
    \frametitle{Kunci Jawaban (5/5 - Solusi 3: DCL)}
    \footnotesize % Tambahan
\begin{minted}[fontsize=\tiny, bgcolor=gray!10]{java}
public class GameManager {
    // Solusi 3: DCL - Perlu volatile!
    private static volatile GameManager instance;
    // ... constructor private ...

    public static GameManager getInstance() {
        if (instance == null) { // Cek 1 (tanpa lock)
            synchronized (GameManager.class) {
                if (instance == null) { // Cek 2 (dengan lock)
                    instance = new GameManager();
                }
            }
        }
        return instance;
    }
}
\end{minted}
\end{frame}
