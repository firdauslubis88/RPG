%----------------------------------------------------------------------------------------
%	WEEK 10: FACTORY METHOD & OBJECT POOL PATTERNS
%----------------------------------------------------------------------------------------

\SetSlideHeaderLevel{section}

\section{Introduction}

\begin{frame}{Week 10 Overview}
    \textbf{Topic:} Creational Design Patterns \& Performance Optimization

    \vspace{0.5cm}
    \textbf{Two Key Patterns:}
    \begin{enumerate}
        \item \textcolor{blue}{\textbf{Factory Method Pattern}} - Flexible object creation
        \item \textcolor{green}{\textbf{Object Pool Pattern}} - Performance optimization
    \end{enumerate}

    \vspace{0.5cm}
    \begin{alertblock}{Four Branches}
        10-01 $\rightarrow$ 10-02 $\rightarrow$ 10-03 $\rightarrow$ 10-04 (Problem $\rightarrow$ Solution $\rightarrow$ Problem $\rightarrow$ Solution)
    \end{alertblock}
\end{frame}

\begin{frame}{What We'll Build}
    \textbf{Dungeon Escape Game Features:}
    \begin{multicols}{2}
        \begin{itemize}
            \item Dynamic obstacle spawning
            \item Three obstacle types (Spike, Goblin, Wolf)
            \item Collision detection
            \item Performance monitoring
            \item Safe spawning algorithm
            \item Object pooling for efficiency
        \end{itemize}
    \end{multicols}

    \vspace{0.3cm}
    \textbf{Learning Outcomes:}
    \begin{enumerate}
        \item Understand extensibility problems
        \item Apply Factory Method pattern
        \item Identify performance bottlenecks
        \item Implement Object Pool pattern
    \end{enumerate}
\end{frame}

%----------------------------------------------------------------------------------------
\section{Branch 10-01: The Problem}

\begin{frame}{10-01: Hard-Coded Object Creation}
    \textbf{Problem:} Switch statement for object creation

    \begin{lstlisting}[language=Java,basicstyle=\ttfamily\tiny]
// WorldController.java - ANTI-PATTERN
private void spawnRandomObstacle() {
    int type = random.nextInt(3);
    int x = random.nextInt(25);
    int y = random.nextInt(25);

    Obstacle newObstacle = null;
    switch (type) {
        case 0: newObstacle = new Spike(x, y); break;
        case 1: newObstacle = new Goblin(x, y); break;
        case 2: newObstacle = new Wolf(x, y); break;
    }
    activeObstacles.add(newObstacle);
}
    \end{lstlisting}

    \textbf{Issues:}
    \begin{itemize}
        \item Tight coupling to concrete classes
        \item Violates Open/Closed Principle
        \item Hard to add new obstacle types
        \item Causes merge conflicts
    \end{itemize}
\end{frame}

\begin{frame}{10-01: Why This is Bad}
    \textbf{Scenario:} Team wants to add new obstacle types

    \vspace{0.3cm}
    \textbf{What happens:}
    \begin{enumerate}
        \item Developer A adds \texttt{case 3: new Dragon()}
        \item Developer B adds \texttt{case 3: new Trap()}
        \item Developer C adds \texttt{case 3: new Boulder()}
        \item \textcolor{red}{\textbf{Merge conflict!}} All editing same switch statement
    \end{enumerate}

    \vspace{0.3cm}
    \begin{block}{Open/Closed Principle Violated}
        Classes should be \textbf{open for extension} but \textbf{closed for modification}. \\
        Switch statement forces modification of existing code.
    \end{block}
\end{frame}

%----------------------------------------------------------------------------------------
\section{Branch 10-02: Factory Method Solution}

\begin{frame}{10-02: Factory Method Pattern}
    \textbf{Solution:} Delegate object creation to factory classes

    \begin{center}
        \includegraphics[width=0.7\textwidth]{../../diagrams/factory-pattern.pdf}
    \end{center}

    \textbf{Key Components:}
    \begin{itemize}
        \item \texttt{ObstacleFactory} interface
        \item \texttt{SpikeFactory}, \texttt{GoblinFactory}, \texttt{WolfFactory}
        \item \texttt{WorldController} uses list of factories
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{10-02: Factory Implementation}
    \textbf{Factory Interface:}
    \begin{lstlisting}[language=Java,basicstyle=\ttfamily\tiny]
public interface ObstacleFactory {
    Obstacle createObstacle(int x, int y);
}
    \end{lstlisting}

    \textbf{Concrete Factory:}
    \begin{lstlisting}[language=Java,basicstyle=\ttfamily\tiny]
public class GoblinFactory implements ObstacleFactory {
    @Override
    public Obstacle createObstacle(int x, int y) {
        return new Goblin(x, y);
    }
}
    \end{lstlisting}

    \textbf{Usage in WorldController:}
    \begin{lstlisting}[language=Java,basicstyle=\ttfamily\tiny]
private List<ObstacleFactory> factories;

private void spawnRandomObstacle() {
    ObstacleFactory factory = factories.get(random.nextInt(factories.size()));
    Obstacle obstacle = factory.createObstacle(x, y);
    activeObstacles.add(obstacle);
}
    \end{lstlisting}
\end{frame}

\begin{frame}{10-02: Benefits}
    \textbf{Advantages of Factory Method:}
    \begin{enumerate}
        \item \textcolor{green}{\textbf{Loose coupling}} - WorldController doesn't know concrete types
        \item \textcolor{green}{\textbf{Open/Closed}} - Add new obstacles without modifying existing code
        \item \textcolor{green}{\textbf{No conflicts}} - Each developer creates their own factory
        \item \textcolor{green}{\textbf{Easy testing}} - Mock factories for unit tests
    \end{enumerate}

    \vspace{0.3cm}
    \begin{exampleblock}{Adding New Obstacle}
        To add \texttt{Dragon}:
        \begin{enumerate}
            \item Create \texttt{Dragon.java} class
            \item Create \texttt{DragonFactory.java}
            \item Register factory in WorldController constructor
            \item Done! No switch statement modification
        \end{enumerate}
    \end{exampleblock}
\end{frame}

%----------------------------------------------------------------------------------------
\section{Branch 10-03: Performance Problem}

\begin{frame}{10-03: The GC Problem}
    \textbf{New Requirement:} Spawn 20 obstacles per second

    \vspace{0.3cm}
    \textbf{What happens:}
    \begin{itemize}
        \item 20 spawns/second Ã— 50 seconds = 1000+ object creations
        \item Objects go off-screen and get garbage collected
        \item \textcolor{red}{\textbf{Garbage Collection pauses freeze the game!}}
    \end{itemize}

    \vspace{0.3cm}
    \begin{alertblock}{Performance Impact}
        \textbf{Branch 10-03:} 1000+ allocations, 9ms GC time \\
        In larger games: Can cause frame drops, stuttering, poor UX
    \end{alertblock}
\end{frame}

\begin{frame}{10-03: GC Monitoring}
    \textbf{Performance Monitor Implementation:}

    \begin{columns}[T]
        \begin{column}{0.48\textwidth}
            \textbf{Metrics Tracked:}
            \begin{itemize}
                \item Frame time (milliseconds)
                \item Average frame time
                \item Worst frame time
                \item Slow frames (< 30 FPS)
                \item GC pause count
                \item Total GC time
            \end{itemize}
        \end{column}
        \begin{column}{0.48\textwidth}
            \textbf{Console Output:}
            \begin{lstlisting}[language=,basicstyle=\ttfamily\tiny,frame=single]
+==================+
| PERFORMANCE      |
+==================+
| Frame: 60        |
| Avg: 1.2ms       |
| Worst: 18.3ms    |
| Slow: 0 (0.0%)   |
+==================+
            \end{lstlisting}
        \end{column}
    \end{columns}

    \textbf{Uses:} \texttt{GarbageCollectorMXBean} API to track GC events
\end{frame}

\begin{frame}[fragile]{10-03: Safe Spawning Algorithm}
    \textbf{Challenge:} Don't spawn obstacles on top of NPC or walls

    \begin{lstlisting}[language=Java,basicstyle=\ttfamily\tiny]
private boolean isSafePosition(int x, int y) {
    // Check 1: Must be walkable floor
    if (!DungeonMap.isWalkable(x, y)) return false;

    // Check 2: Must not be too close to NPC (minimum 3 tiles)
    int distance = Math.abs(x - npc.getX()) + Math.abs(y - npc.getY());
    if (distance < 3) return false;

    // Check 3: Must not overlap with existing obstacles
    for (Obstacle obs : activeObstacles) {
        if (obs.getX() == x && obs.getY() == y) return false;
    }
    return true;
}
    \end{lstlisting}

    \textbf{Algorithm:} Try max 10 times to find safe position, give up if not found
\end{frame}

%----------------------------------------------------------------------------------------
\section{Branch 10-04: Object Pool Solution}

\begin{frame}{10-04: Object Pool Pattern}
    \textbf{Idea:} Reuse objects instead of creating new ones

    \begin{center}
        \includegraphics[width=0.8\textwidth]{../../diagrams/object-pool-pattern.pdf}
    \end{center}

    \textbf{How it works:}
    \begin{enumerate}
        \item Pre-allocate 50 objects at startup
        \item \texttt{acquire()} borrows from pool
        \item \texttt{release()} returns to pool
        \item Reuse instead of recreate
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{10-04: Pool Implementation}
    \begin{lstlisting}[language=Java,basicstyle=\ttfamily\tiny]
public class ObstaclePool {
    private final List<Obstacle> availableObstacles;
    private final List<Obstacle> allObstacles;
    private final ObstacleFactory factory;

    public ObstaclePool(ObstacleFactory factory, int initialSize) {
        this.availableObstacles = new ArrayList<>();
        this.allObstacles = new ArrayList<>();

        // Pre-allocate at startup
        for (int i = 0; i < initialSize; i++) {
            Obstacle obstacle = factory.createObstacle(0, 0);
            obstacle.setActive(false);
            availableObstacles.add(obstacle);
            allObstacles.add(obstacle);
        }
    }

    public Obstacle acquire(int x, int y) {
        if (!availableObstacles.isEmpty()) {
            Obstacle obstacle = availableObstacles.remove(availableObstacles.size() - 1);
            obstacle.reset(x, y);
            obstacle.setActive(true);
            return obstacle;
        }
        return null; // Pool exhausted
    }

    public void release(Obstacle obstacle) {
        obstacle.setActive(false);
        availableObstacles.add(obstacle);
    }
}
    \end{lstlisting}
\end{frame}

\begin{frame}{10-04: Performance Comparison}
    \begin{center}
        \includegraphics[width=0.9\textwidth]{../../diagrams/gc-performance.pdf}
    \end{center}

    \vspace{0.3cm}
    \begin{block}{Results}
        \begin{itemize}
            \item 10-03: 1000+ creates, 9ms GC time
            \item 10-04: 150 creates, 860+ reuses, 8ms GC time
            \item \textbf{Key:} Pattern scales better (not raw numbers)
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{10-04: Pool Statistics}
    \textbf{Branch 10-04 tracks pool usage:}

    \begin{lstlisting}[language=,basicstyle=\ttfamily\tiny,frame=single]
=== POOL STATISTICS ===
Spike Pool Stats:
  Total Created: 50
  Acquire Calls: 334
  Release Calls: 284
  Total Size: 50
  Available: 0
  In Use: 50

Goblin Pool Stats:
  Total Created: 50
  Acquire Calls: 334
  Release Calls: 284
  ...
    \end{lstlisting}

    \textbf{Analysis:}
    \begin{itemize}
        \item 50 created (at startup)
        \item 334 acquires = 334 times spawned
        \item 284 releases = 284 returned
        \item \textcolor{green}{\textbf{Result: 284 reuses! (85\% reuse rate)}}
    \end{itemize}
\end{frame}

%----------------------------------------------------------------------------------------
\section{Design Evolution}

\begin{frame}{Architecture Evolution}
    \begin{center}
        \includegraphics[width=0.95\textwidth]{../../diagrams/architecture-comparison.pdf}
    \end{center}
\end{frame}

\begin{frame}{Key Takeaways}
    \textbf{Factory Method Pattern:}
    \begin{itemize}
        \item Solves: Tight coupling, extensibility problems
        \item Benefits: Loose coupling, Open/Closed, no merge conflicts
        \item Trade-off: More classes (but worth it!)
    \end{itemize}

    \vspace{0.3cm}
    \textbf{Object Pool Pattern:}
    \begin{itemize}
        \item Solves: GC pressure from frequent allocation
        \item Benefits: Stable performance, minimal allocation
        \item Trade-off: Memory overhead, complexity
    \end{itemize}

    \vspace{0.3cm}
    \begin{alertblock}{When to Use}
        \textbf{Factory:} When you need flexible object creation \\
        \textbf{Pool:} When you create/destroy many short-lived objects
    \end{alertblock}
\end{frame}

\begin{frame}{Real-World Applications}
    \textbf{Factory Method:}
    \begin{itemize}
        \item GUI frameworks (button factories)
        \item Database connectors (driver factories)
        \item Logging systems (logger factories)
    \end{itemize}

    \vspace{0.3cm}
    \textbf{Object Pool:}
    \begin{itemize}
        \item Database connection pools
        \item Thread pools
        \item Game engines (particle systems, projectiles)
        \item Network socket pools
    \end{itemize}
\end{frame}

%----------------------------------------------------------------------------------------
\section{Summary}

\begin{frame}{Week 10 Summary}
    \textbf{What We Learned:}
    \begin{enumerate}
        \item Identified extensibility problems (switch statements)
        \item Applied Factory Method for flexible creation
        \item Measured GC performance with monitoring tools
        \item Implemented Object Pool for performance optimization
    \end{enumerate}

    \vspace{0.3cm}
    \textbf{Design Principles Applied:}
    \begin{itemize}
        \item Open/Closed Principle
        \item Dependency Inversion Principle
        \item Separation of Concerns
        \item Performance-aware design
    \end{itemize}

    \vspace{0.3cm}
    \begin{block}{Branch Structure}
        \texttt{10-01} (problem) $\rightarrow$ \texttt{10-02} (factory) $\rightarrow$ \texttt{10-03} (GC) $\rightarrow$ \texttt{10-04} (pool)
    \end{block}
\end{frame}
