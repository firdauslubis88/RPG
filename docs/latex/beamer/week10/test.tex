\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{minted}
\usepackage{tikz}
\usetikzlibrary{shapes.multipart, positioning, arrows.meta, shapes.standard}

% --- Theme and Color Scheme ---
\usetheme{Madrid}
\usecolortheme{default}

% --- Minted Setup ---
% 'minted' memerlukan flag '-shell-escape' saat kompilasi
% Contoh: pdflatex -shell-escape namafile.tex
% Di Overleaf, ini bisa diatur di menu 'Compiler'.
\setminted{
    style=manni,
    breaklines,
    breakanywhere,
    fontsize=\footnotesize,
    linenos
}

% --- Custom TikZ Styles for Linked List Nodes (FIXED) ---
\tikzset{
    % Style untuk node Linked List menggunakan 'record' shape yang lebih robust
    ll_node/.style={
        draw,
        shape=record,
        align=center,
        minimum height=0.8cm
    }
}


% --- Title Information ---
\title[Alpro - Pekan 2]{Pekan 2: Struktur Data Linear - Linked List}
\author{Departemen Teknik Elektro UI}
\institute{Program Studi Sarjana Teknik Komputer}
\date{\today}

\begin{document}

% --- Title Page ---
\begin{frame}
    \titlepage
\end{frame}

% --- Section 1: Recap & Motivation ---
\section{Rekap \& Motivasi}

\begin{frame}{Rekap Pekan 1}
    \begin{block}{Apa yang Telah Kita Pelajari?}
        \begin{itemize}
            \item<1-> Konsep dasar algoritma dan analisis efisiensi (Big-O).
            \item<2-> Tiga algoritma sorting dasar: Bubble, Selection, dan Insertion Sort.
            \item<3-> Implementasi algoritma-algoritma tersebut menggunakan \textbf{array statis} dan `std::vector` di C++.
        \end{itemize}
    \end{block}
    
    \onslide<4->{
    \begin{alertblock}{Fokus Pekan Ini}
        Kita akan beralih dari struktur data berbasis memori yang bersebelahan (kontigu) seperti array, ke struktur data berbasis pointer yang lebih dinamis: \textbf{Linked List}.
    \end{alertblock}
    }
\end{frame}

\begin{frame}{Motivasi: Kenapa Perlu Linked List?}
    \begin{block}{Keterbatasan Array / Vector}
        \begin{itemize}
            \item \textbf{Ukuran Statis (untuk C-style array):} Ukuran harus ditentukan di awal dan tidak bisa berubah.
            \item \textbf{Alokasi Ulang (untuk vector):} Walaupun dinamis, jika `vector` penuh dan kita menambahkan elemen baru, ia akan mengalokasikan blok memori baru yang lebih besar dan menyalin semua elemen lama. Ini bisa jadi mahal.
            \item<2-> \textbf{Operasi Sisip \& Hapus yang Mahal:} Untuk menyisipkan atau menghapus elemen di tengah, semua elemen setelahnya harus digeser. Ini adalah operasi $O(n)$.
        \end{itemize}
    \end{block}
    
    \onslide<3->{
    \begin{exampleblock}{Pertanyaan}
        Bagaimana jika kita butuh struktur data yang ukurannya bisa bertumbuh secara organik dan operasi sisip/hapus di mana saja bisa dilakukan dengan sangat cepat?
    \end{exampleblock}
    }
\end{frame}

% --- Section 2: Singly Linked List ---
\section{Singly Linked List}

\begin{frame}{Konsep Singly Linked List (SLL)}
    \begin{block}{Ide Utama}
        Sebuah koleksi dari `node` di mana setiap `node` berisi dua hal:
        \begin{enumerate}
            \item Data yang disimpan.
            \item Sebuah pointer (`next`) yang menunjuk ke `node` berikutnya dalam urutan.
        \end{enumerate}
        Node terakhir menunjuk ke `NULL`.
    \end{block}
    
    \begin{center}
        \onslide<2->{
        \begin{tikzpicture}
            % Definisi Node menggunakan manual placement dan record shape
            \node (head) {head};
            \node[ll_node, label=below:{\tiny(0x100)}] (A) at (2.5,0) { {12} | <next> \tiny next };
            \node[ll_node, label=below:{\tiny(0x180)}] (B) at (6,0)   { {99} | <next> \tiny next };
            \node[ll_node, label=below:{\tiny(0x210)}] (C) at (9.5,0)  { {37} | <next> \tiny next };
            \node (null) at (11.5,0) {NULL};
            
            % Pointer
            \draw[-{Stealth}] (head.east) -- (A.west);
            \draw[-{Stealth}] (A.next) -- (B.west);
            \draw[-{Stealth}] (B.next) -- (C.west);
            \draw[-{Stealth}] (C.next) -- (null.west);
        \end{tikzpicture}
        }
    \end{center}
    
    \onslide<3->{
    \begin{alertblock}{Keunggulan Konseptual}
        Ukuran bisa bertambah atau berkurang satu per satu. Untuk menyisipkan node baru, kita hanya perlu mengubah beberapa pointer, tidak perlu menggeser elemen!
    \end{alertblock}
    }
\end{frame}

\begin{frame}[fragile]{Operasi 1: Traversal (Pencarian)}
    \begin{block}{Logika}
        Untuk mencari sebuah elemen atau mengunjungi setiap node, kita harus memulai dari `head` dan mengikuti pointer `next` satu per satu hingga mencapai akhir list (`NULL`).
    \end{block}

    \begin{center}
    \begin{tikzpicture}
        \node (head) {head};
        \node[ll_node] (A) at (2.5,0) { {12} | <next> };
        \node[ll_node] (B) at (5.5,0) { {99} | <next> };
        \node[ll_node] (C) at (8.5,0) { {37} | <next> };
        \node (null) at (10.5,0) {NULL};
        
        \draw[-{Stealth}] (head.east) -- (A.west);
        \draw[-{Stealth}] (A.next) -- (B.west);
        \draw[-{Stealth}] (B.next) -- (C.west);
        \draw[-{Stealth}] (C.next) -- (null.west);

        \node[draw, circle, red] (current) at (A.north) {\tiny current};
        \draw[-{Stealth}, red, thick] (current) to[bend left=45] (B.north);
        \onslide<2->{
        \node[draw, circle, red] (current2) at (B.north) {\tiny current};
        \draw[-{Stealth}, red, thick] (current2) to[bend left=45] (C.north);
        }
        \onslide<3->{
        \node[draw, circle, red] (current3) at (C.north) {\tiny current};
        \draw[-{Stealth}, red, thick] (current3) to[bend left=45] (null.north);
        }
    \end{tikzpicture}
    \end{center}
    
    \onslide<4->{
    \begin{alertblock}{Analisis}
        Karena kita harus mengunjungi setiap node pada kasus terburuk, operasi traversal dan pencarian memiliki kompleksitas waktu $O(n)$.
    \end{alertblock}
    }
\end{frame}

\begin{frame}[fragile]{Operasi 2: Penambahan di Awal (Prepend)}
    \begin{block}{Logika}
        Ini adalah operasi paling efisien di SLL.
        \begin{enumerate}
            \item Buat sebuah `newNode`.
            \item Atur `newNode->next` agar menunjuk ke `head` saat ini.
            \item Pindahkan `head` agar menunjuk ke `newNode`.
        \end{enumerate}
    \end{block}
    
    \begin{center}
    \begin{tikzpicture}
        \node[ll_node] (newNode) at (0, -1.5) { {5} | <next> };
        \node (head) at (0,0) {head};
        \node[ll_node] (A) at (2.5,0) { {12} | <next> };
        \node[ll_node] (B) at (5.5,0) { {99} | <next> };
        
        \draw[-{Stealth}] (head.east) -- (A.west);
        \draw[-{Stealth}] (A.next) -- (B.west);

        \onslide<2->{
        \draw[-{Stealth}, blue, dashed] (newNode.next) -- (A.south) node[midway, below] {\tiny 1. Atur next};
        }
        \onslide<3->{
        \draw[-{Stealth}, red, dashed] (head.south) to[bend right=45] (newNode.north) node[midway, left] {\tiny 2. Pindahkan head};
        }
    \end{tikzpicture}
    \end{center}
    
    \onslide<4->{
    \begin{alertblock}{Analisis}
        Operasi ini hanya butuh beberapa manipulasi pointer, tidak peduli seberapa panjang listnya. Kompleksitas waktu: $O(1)$.
    \end{alertblock}
    }
\end{frame}

\begin{frame}[fragile]{Operasi 3: Penyisipan di Tengah}
    \begin{block}{Logika}
        Untuk menyisipkan `newNode` setelah `node P`:
        \begin{enumerate}
            \item Atur `newNode->next` agar menunjuk ke node setelah P (`P->next`).
            \item Atur `P->next` agar menunjuk ke `newNode`.
        \end{enumerate}
    \end{block}
    
    \begin{center}
    \begin{tikzpicture}
        \node[ll_node] (P) at (0,0) { {12} | <next> };
        \node[ll_node] (Q) at (3,0) { {99} | <next> };
        \node[ll_node] (newNode) at (1.5, -1.5) { {5} | <next> };
        
        \draw[-{Stealth}] (P.next) -- (Q.west);
        
        \onslide<2->{
        \draw[-{Stealth}, blue, dashed] (newNode.next) -- (Q.south) node[midway, below] {\tiny 1. Sambungkan newNode ke Q};
        }
        \onslide<3->{
        \draw[white, line width=4pt] (P.next) -- (Q.west); % Menghapus panah lama
        \draw[-{Stealth}, red, dashed] (P.next) -- (newNode.north) node[midway, left] {\tiny 2. Sambungkan P ke newNode};
        }
    \end{tikzpicture}
    \end{center}
    
    \onslide<4->{
    \begin{alertblock}{Analisis}
        Jika kita sudah memiliki pointer ke node `P`, operasi ini hanya butuh 2 langkah. Kompleksitas waktu: $O(1)$. (Namun, mencari `P` sendiri butuh $O(n)$).
    \end{alertblock}
    }
\end{frame}

\begin{frame}[fragile]{Operasi 4: Penghapusan Node}
    \begin{block}{Logika}
        Untuk menghapus node setelah `node P`:
        \begin{enumerate}
            \item Buat pointer sementara `nodeToDelete` yang menunjuk ke `P->next`.
            \item Atur `P->next` agar menunjuk ke `nodeToDelete->next`. Ini "melompati" node yang akan dihapus.
            \item Hapus `nodeToDelete` dari memori.
        \end{enumerate}
    \end{block}
    
    \begin{center}
    \begin{tikzpicture}
        \node[ll_node] (P) at (0,0) { {12} | <next> };
        \node[ll_node, fill=red!20] (del) at (3,0) { {5} | <next> };
        \node[ll_node] (Q) at (6,0) { {99} | <next> };
        
        \draw[-{Stealth}] (P.next) -- (del.west);
        \draw[-{Stealth}] (del.next) -- (Q.west);
        
        \onslide<2->{
        \draw[-{Stealth}, blue, dashed, thick] (P.next) to[bend left=45] (Q.west) node[midway, above] {\tiny "Lompati" node};
        }
    \end{tikzpicture}
    \end{center}
    
    \onslide<3->{
    \begin{alertblock}{Analisis}
        Sama seperti penyisipan, jika kita sudah punya pointer ke node `P` (node sebelum yang akan dihapus), operasinya sangat cepat: $O(1)$.
    \end{alertblock}
    }
\end{frame}


\begin{frame}{Operasi Dasar: Array vs. Linked List}
    \footnotesize
    \begin{block}{Perbandingan Konseptual}
        \begin{tabular}{|l|c|c|}
            \hline
            \textbf{Operasi} & \textbf{Array / Vector} & \textbf{Singly Linked List} \\ \hline
            \onslide<2->{Akses elemen ke-i} & \onslide<2->{$O(1)$} & \onslide<2->{$O(n)$} \\
            \onslide<3->{Searching (pencarian)} & \onslide<3->{$O(n)$} & \onslide<3->{$O(n)$} \\
            \onslide<4->{Insert/Delete di akhir} & \onslide<4->{$O(1)$ (amortized)} & \onslide<4->{$O(n)$ (harus ke akhir dulu)} \\
            \onslide<5->{Insert/Delete di awal} & \onslide<5->{$O(n)$} & \onslide<5->{$O(1)$} \\
            \onslide<6->{Insert/Delete di tengah} & \onslide<6->{$O(n)$} & \onslide<6->{$O(1)$ (jika sudah punya pointer)} \\
            \hline
        \end{tabular}
    \end{block}
    
    \begin{alertblock}<7->{Kesimpulan}
        Linked List unggul telak pada operasi sisip/hapus di awal atau tengah, namun kalah telak pada akses acak (random access).
    \end{alertblock}
\end{frame}

\begin{frame}[fragile]{Implementasi SLL di C++}
    \begin{block}{Mendefinisikan `Node` dengan `struct`}
\begin{minted}{cpp}
struct Node {
    int data;       // Data yang disimpan
    Node* next;     // Pointer ke node berikutnya

    // Constructor untuk kemudahan
    Node(int val) : data(val), next(nullptr) {}
};
\end{minted}
    \end{block}
    
    \begin{exampleblock}{Visualisasi Operasi: Insert di Awal}
        \only<2>{\includegraphics[width=0.9\textwidth]{https://i.imgur.com/7g9xQ2s.png}}
        \only<3>{\includegraphics[width=0.9\textwidth]{https://i.imgur.com/Qk7Yj9R.png}}
        \only<4>{\includegraphics[width=0.9\textwidth]{https://i.imgur.com/wGf8t4H.png}}
        \tiny\onslide<2->{[Gambar Visualisasi Langkah Demi Langkah Operasi Insert di Awal]}
    \end{exampleblock}
    
    \begin{alertblock}<5->{Peran Pointer}
        Perhatikan bagaimana kita hanya memanipulasi alamat memori (`next` dan `head`) untuk menyisipkan elemen baru tanpa memindahkan data yang sudah ada.
    \end{alertblock}
\end{frame}

% --- Section 3: Doubly Linked List ---
\section{Doubly Linked List}

\begin{frame}{Motivasi Doubly Linked List (DLL)}
    \begin{block}{Keterbatasan SLL}
        Pada Singly Linked List, kita hanya bisa bergerak maju.
    \end{block}
    
    \pause
    
    \begin{exampleblock}{Pertanyaan}
        Bagaimana jika kita berada di sebuah node di tengah-tengah list dan perlu mengakses node \textbf{sebelumnya}? Di SLL, kita harus kembali dari `head` dan melakukan traversal ulang ($O(n)$). Sangat tidak efisien.
    \end{exampleblock}
    
    \onslide<3->{
    \begin{alertblock}{Solusi: Doubly Linked List}
        Tambahkan satu pointer lagi di setiap node: pointer `prev` yang menunjuk ke node sebelumnya.
    \end{alertblock}
    }
\end{frame}

\begin{frame}[fragile]{Implementasi DLL di C++}
    \begin{block}{Mendefinisikan `Node` untuk DLL}
\begin{minted}{cpp}
struct Node {
    int data;
    Node* next;     // Pointer ke node berikutnya
    Node* prev;     // Pointer ke node sebelumnya

    Node(int val) : data(val), next(nullptr), prev(nullptr) {}
};
\end{minted}
    \end{block>
    
    \begin{exampleblock}{Visualisasi Konsep DLL}
        \onslide<2->{
        \begin{tikzpicture}
            % Definisi Node menggunakan manual placement dan record shape
            \node (head) {head};
            \node[ll_node, label=below:{\tiny(0x100)}] (A) at (2.5,0) {<prev> \tiny prev | {12} | <next> \tiny next};
            \node[ll_node, label=below:{\tiny(0x180)}] (B) at (6.5,0) {<prev> \tiny prev | {99} | <next> \tiny next};
            \node[ll_node, label=below:{\tiny(0x210)}] (C) at (10.5,0){<prev> \tiny prev | {37} | <next> \tiny next};
            
            % Pointer Next (atas)
            \draw[-{Stealth}] (head.east) -- (A.west);
            \draw[-{Stealth}] (A.next) to [bend left=20] (B.west);
            \draw[-{Stealth}] (B.next) to [bend left=20] (C.west);
            
            % Pointer Prev (bawah)
            \draw[-{Stealth}] (C.prev) to [bend right=20] (B.east);
            \draw[-{Stealth}] (B.prev) to [bend right=20] (A.east);
        \end{tikzpicture}
        }
    \end{exampleblock}
\end{frame}

% --- Section 4: Application & Challenge ---
\section{Aplikasi \& Tantangan}

\begin{frame}{Tantangan 1: Sorting pada Linked List}
    \begin{block}{Saatnya Praktik}
        Sekarang, Anda sudah paham cara kerja array dan linked list.
    \end{block}
    
    \begin{alertblock}{Tantangan}
        Bagaimana Anda akan mengadaptasi salah satu dari tiga algoritma sorting dasar (Bubble, Insertion, atau Selection Sort) yang sebelumnya bekerja pada array, agar bisa bekerja pada \textbf{Singly Linked List} yang baru saja kita buat?
    \end{alertblock}
    
    \begin{exampleblock}<2->{Petunjuk}
        Fokus pada manipulasi pointer `next`, bukan menukar `data`. Operasi `swap` menjadi lebih rumit!
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{STL to the Rescue: `std::list`}
    \begin{block}{Kontainer Bawaan C++}
        C++ menyediakan implementasi Doubly Linked List yang sudah teruji dan efisien, yaitu `std::list`.
    \end{block}
    
    \begin{exampleblock}{Contoh Penggunaan `std::list`}
\begin{minted}{cpp}
#include <iostream>
#include <list>

int main() {
    std::list<int> myList;
    myList.push_back(10);   // Tambah di akhir
    myList.push_front(20);  // Tambah di awal
    
    // Iterasi menggunakan iterator
    for (auto it = myList.begin(); it != myList.end(); ++it) {
        std::cout << *it << " ";
    }
    // Output: 20 10
    return 0;
}
\end{minted}
    \end{exampleblock}
    
    \begin{alertblock}<2->{Tantangan 2}
        Cobalah implementasikan salah satu algoritma sorting dasar menggunakan `std::list`. Anda akan menyadari bahwa Anda tidak bisa menggunakan akses indeks `[]`! Anda harus menggunakan iterator.
    \end{alertblock}
\end{frame}

\begin{frame}{Penutup & Motivasi Lanjutan}
    \begin{block}{Wawasan Kunci}
        \begin{itemize}
            \item Kita telah memahami perbedaan fundamental antara array dan linked list.
            \item Kita telah belajar mengimplementasikan SLL dan DLL dari nol.
            \item Kita sadar bahwa pilihan struktur data sangat mempengaruhi cara kita menulis algoritma.
        \end{itemize}
    \end{block}
    
    \begin{alertblock}{Pertanyaan Refleksi}
        Algoritma sorting dasar ($O(n^2)$) terasa sangat tidak efisien dan rumit untuk diimplementasikan pada linked list. Apakah ada cara yang lebih baik?
    \end{alertblock}
    
    \begin{center}
        \Large\bfseries
        \onslide<2->{Pertemuan berikutnya: \textit{Merge Sort}}
    \end{center}
\end{frame}

\end{document}
